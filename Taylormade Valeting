# Replace YOUR_GITHUB_USERNAME with your actual username
git clone https://github.com/YOUR_GITHUB_USERNAME/detailermade-uk.git
cd detailermade-uk
-- db/schema.sql
-- PostgreSQL schema for UK-ready car detailing app
-- Monetary amounts stored as integer pence (e.g. 1250 = Â£12.50)

CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- users
CREATE TABLE users (
  id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  email TEXT UNIQUE NOT NULL,
  password_hash TEXT NOT NULL,
  full_name TEXT,
  phone_e164 TEXT, -- store in E.164 (+44...) format
  role TEXT NOT NULL DEFAULT 'customer', -- customer, technician, admin
  gdpr_consent BOOLEAN NOT NULL DEFAULT FALSE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX ON users (email);

-- vehicles
CREATE TABLE vehicles (
  id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id uuid REFERENCES users(id) ON DELETE CASCADE,
  reg_number TEXT, -- UK reg plate
  make TEXT,
  model TEXT,
  year integer,
  notes TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX ON vehicles (user_id);

-- services
CREATE TABLE services (
  id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  title TEXT NOT NULL,
  description TEXT,
  base_price_pence integer NOT NULL CHECK (base_price_pence >= 0),
  duration_minutes integer NOT NULL DEFAULT 60,
  taxable boolean NOT NULL DEFAULT TRUE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- technicians
CREATE TABLE technicians (
  id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id uuid REFERENCES users(id) ON DELETE CASCADE,
  travel_radius_km integer DEFAULT 20,
  hourly_rate_pence integer,
  insured boolean DEFAULT FALSE,
  insurance_certificate_url TEXT,
  available_schedule jsonb, -- e.g. {"mon": ["08:00-12:00","13:00-18:00"], ...}
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX ON technicians (user_id);

-- bookings
CREATE TYPE booking_status AS ENUM ('pending','confirmed','in_progress','completed','cancelled');

CREATE TABLE bookings (
  id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id uuid REFERENCES users(id) ON DELETE SET NULL,
  technician_id uuid REFERENCES technicians(id) ON DELETE SET NULL,
  vehicle_id uuid REFERENCES vehicles(id) ON DELETE SET NULL,
  service_id uuid REFERENCES services(id) ON DELETE SET NULL,
  start_at TIMESTAMPTZ NOT NULL,
  end_at TIMESTAMPTZ NOT NULL,
  location jsonb, -- { "address": "...", "postcode": "SW1A 1AA", "lat": 51.5, "lng": -0.1 }
  status booking_status NOT NULL DEFAULT 'pending',
  total_price_pence integer NOT NULL CHECK (total_price_pence >= 0),
  vat_amount_pence integer NOT NULL DEFAULT 0,
  payment_status TEXT NOT NULL DEFAULT 'unpaid', -- unpaid, paid, refunded
  stripe_payment_intent_id TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX ON bookings (user_id);
CREATE INDEX ON bookings (technician_id);
CREATE INDEX ON bookings (start_at);

-- reviews
CREATE TABLE reviews (
  id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  booking_id uuid REFERENCES bookings(id) ON DELETE CASCADE,
  user_id uuid REFERENCES users(id) ON DELETE SET NULL,
  rating smallint CHECK (rating >= 1 AND rating <= 5),
  text TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- audit logs - minimal
CREATE TABLE audit_logs (
  id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  actor_user_id uuid REFERENCES users(id) ON DELETE SET NULL,
  action TEXT NOT NULL,
  meta jsonb,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- sample seed for services
INSERT INTO services (title, description, base_price_pence, duration_minutes, taxable)
VALUES
  ('Quick Wash', 'Exterior wash and dry', 1500, 30, TRUE),
  ('Full Valet', 'Interior + exterior deep clean', 4500, 120, TRUE),
  ('Ceramic Coating (single stage)', 'Paint protection', 120000, 240, TRUE)
ON CONFLICT DO NOTHING;
{
  "name": "detailermade-uk-backend",
  "version": "1.0.0",
  "main": "src/index.js",
  "scripts": {
    "start": "node src/index.js",
    "dev": "nodemon --watch src --exec node src/index.js",
    "migrate": "psql $DATABASE_URL -f ../db/schema.sql"
  },
  "dependencies": {
    "bcrypt": "^5.1.0",
    "body-parser": "^1.20.2",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "jsonwebtoken": "^9.0.0",
    "node-fetch": "^3.4.1",
    "pg": "^8.11.1",
    "stripe": "^12.12.0",
    "libphonenumber-js": "^1.10.23",
    "uuid": "^9.0.0"
  },
  "devDependencies": {
    "nodemon": "^3.0.1"
  }
}
# Server
PORT=3000
NODE_ENV=development
JWT_SECRET=replace_this_with_a_strong_random_string
JWT_EXPIRES_IN=7d

# Postgres (development)
DATABASE_URL=postgresql://postgres:postgres@db:5432/detailermade_dev

# Stripe
STRIPE_SECRET_KEY=sk_test_yourkey
STRIPE_WEBHOOK_SECRET=whsec_yourkey

# Twilio (optional)
TWILIO_ACCOUNT_SID=your_account_sid
TWILIO_AUTH_TOKEN=your_auth_token
TWILIO_SENDER_NUMBER=+447900000000

# Postcodes.io (no key required, but if using alternatives you can configure)
POSTCODESIO_API=https://api.postcodes.io

# App
APP_BASE_URL=http://localhost:3000
// server/src/db.js
const { Pool } = require('pg');
const connectionString = process.env.DATABASE_URL;

if (!connectionString) {
  console.error('DATABASE_URL not set in env');
  process.exit(1);
}

const pool = new Pool({
  connectionString
});

module.exports = {
  query: (text, params) => pool.query(text, params),
  pool
};
// server/src/auth.js
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const db = require('./db');

const JWT_SECRET = process.env.JWT_SECRET || 'dev-secret';
const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '7d';

async function hashPassword(plain) {
  const saltRounds = 12;
  return bcrypt.hash(plain, saltRounds);
}

async function comparePassword(plain, hash) {
  return bcrypt.compare(plain, hash);
}

function generateToken(user) {
  const payload = { id: user.id, email: user.email, role: user.role };
  return jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });
}

async function createUser({ email, password, full_name, phone_e164, gdpr_consent }) {
  const pwHash = await hashPassword(password);
  const res = await db.query(
    `INSERT INTO users (email, password_hash, full_name, phone_e164, gdpr_consent)
     VALUES ($1,$2,$3,$4,$5) RETURNING id,email,full_name,phone_e164,role,created_at`,
    [email, pwHash, full_name, phone_e164, gdpr_consent === true]
  );
  return res.rows[0];
}

async function findUserByEmail(email) {
  const res = await db.query('SELECT * FROM users WHERE email = $1', [email]);
  return res.rows[0];
}

module.exports = {
  hashPassword,
  comparePassword,
  generateToken,
  createUser,
  findUserByEmail
};
// server/src/middleware.js
const jwt = require('jsonwebtoken');
const JWT_SECRET = process.env.JWT_SECRET || 'dev-secret';

function requireAuth(req, res, next) {
  const header = req.headers.authorization;
  if (!header) return res.status(401).json({ error: 'Missing Authorization header' });
  const parts = header.split(' ');
  if (parts.length !== 2 || parts[0] !== 'Bearer') return res.status(401).json({ error: 'Invalid Authorization format' });

  const token = parts[1];
  try {
    const payload = jwt.verify(token, JWT_SECRET);
    req.user = payload;
    next();
  } catch (err) {
    return res.status(401).json({ error: 'Invalid or expired token' });
  }
}

function asyncHandler(fn) {
  return function (req, res, next) {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
}

module.exports = { requireAuth, asyncHandler };
// server/src/index.js
require('dotenv').config();
const express = require('express');
const bodyParser = require('body-parser');
const fetch = require('node-fetch');
const Stripe = require('stripe');
const { v4: uuidv4 } = require('uuid');
const db = require('./db');
const auth = require('./auth');
const { requireAuth, asyncHandler } = require('./middleware');
const { parsePhoneNumberFromString } = require('libphonenumber-js');

const app = express();
app.use(bodyParser.json());

// Basic health
app.get('/', (req, res) => res.json({ ok: true, now: new Date().toISOString() }));

/**
 * AUTH
 */

// register
app.post('/api/auth/register', asyncHandler(async (req, res) => {
  const { email, password, full_name, phone, gdpr_consent } = req.body;
  if (!email || !password) return res.status(400).json({ error: 'email and password required' });

  // optionally normalise phone to E.164 for UK numbers
  let phone_e164 = null;
  if (phone) {
    const pn = parsePhoneNumberFromString(phone, 'GB');
    if (!pn || !pn.isValid()) return res.status(400).json({ error: 'Invalid UK phone number' });
    phone_e164 = pn.number; // E.164
  }

  const existing = await auth.findUserByEmail(email);
  if (existing) return res.status(400).json({ error: 'Email already registered' });

  const user = await auth.createUser({
    email,
    password,
    full_name,
    phone_e164,
    gdpr_consent: !!gdpr_consent
  });

  const token = auth.generateToken(user);
  res.json({ user, token });
}));

// login
app.post('/api/auth/login', asyncHandler(async (req, res) => {
  const { email, password } = req.body;
  if (!email || !password) return res.status(400).json({ error: 'email and password required' });

  const user = await auth.findUserByEmail(email);
  if (!user) return res.status(401).json({ error: 'Invalid credentials' });

  const valid = await auth.comparePassword(password, user.password_hash);
  if (!valid) return res.status(401).json({ error: 'Invalid credentials' });

  const token = auth.generateToken(user);
  // sanitize user
  const safeUser = {
    id: user.id,
    email: user.email,
    full_name: user.full_name,
    phone_e164: user.phone_e164,
    role: user.role
  };
  res.json({ user: safeUser, token });
}));

/**
 * SERVICES
 */
app.get('/api/services', asyncHandler(async (req, res) => {
  const result = await db.query('SELECT id, title, description, base_price_pence, duration_minutes, taxable FROM services ORDER BY created_at');
  res.json({ services: result.rows });
}));

app.get('/api/services/:id', asyncHandler(async (req, res) => {
  const { id } = req.params;
  const r = await db.query('SELECT id, title, description, base_price_pence, duration_minutes, taxable FROM services WHERE id = $1', [id]);
  if (r.rows.length === 0) return res.status(404).json({ error: 'Service not found' });
  res.json({ service: r.rows[0] });
}));

/**
 * TECHNICIANS - simple list & availability check placeholder
 */
app.get('/api/technicians', asyncHandler(async (req, res) => {
  const { postcode, service_id, date } = req.query;
  // In a real app we'd: find technicians within X km of postcode, filter by availability + skills
  const r = await db.query(`
    SELECT t.id, t.user_id, u.full_name, u.phone_e164, t.travel_radius_km, t.hourly_rate_pence, t.available_schedule
    FROM technicians t
    JOIN users u ON t.user_id = u.id
    ORDER BY u.full_name
  `);
  res.json({ technicians: r.rows, note: 'Filtering by postcode/service/date not yet implemented in this scaffold' });
}));

/**
 * BOOKINGS - create + get + update
 *
 * Creating booking flow:
 *  - client calls POST /api/bookings with chosen service, start_at, location, vehicle (or vehicle_id)
 *  - backend calculates end_at (using service duration), computes prices (VAT), inserts booking with status 'pending'
 *  - backend creates Stripe PaymentIntent and returns client_secret
 *  - client collects payment (Stripe SDK). Stripe webhook updates payment_status -> paid
 */

// util to compute vat (20% standard)
function calculateVat(amountPence, vatRate = 0.20) {
  const vat = Math.round(amountPence * vatRate);
  return vat;
}

app.post('/api/bookings', asyncHandler(async (req, res) => {
  const { service_id, start_at, location, vehicle_id, vehicle, customer_email, technician_id } = req.body;
  if (!service_id || !start_at || !location) return res.status(400).json({ error: 'service_id, start_at and location required' });

  // fetch service to get duration & price
  const srv = await db.query('SELECT id, base_price_pence, duration_minutes, taxable FROM services WHERE id = $1', [service_id]);
  if (srv.rows.length === 0) return res.status(400).json({ error: 'Invalid service' });
  const service = srv.rows[0];

  const startTS = new Date(start_at);
  if (isNaN(startTS.getTime())) return res.status(400).json({ error: 'Invalid start_at timestamp' });

  const endTS = new Date(startTS.getTime() + (service.duration_minutes * 60 * 1000));

  // price and VAT
  const basePrice = service.base_price_pence;
  const vatAmount = service.taxable ? calculateVat(basePrice, 0.20) : 0;
  const total = basePrice + vatAmount;

  // optional vehicle creation if vehicle object passed
  let vehicleIdToUse = vehicle_id;
  if (!vehicleIdToUse && vehicle && req.headers.authorization) {
    // if user is logged in, create vehicle linked to user
    const token = req.headers.authorization.split(' ')[1];
    try {
      const payload = require('jsonwebtoken').verify(token, process.env.JWT_SECRET || 'dev-secret');
      if (payload && payload.id) {
        const insert = await db.query(
          `INSERT INTO vehicles (user_id, reg_number, make, model, year, notes) VALUES ($1,$2,$3,$4,$5,$6) RETURNING id`,
          [payload.id, vehicle.reg_number, vehicle.make, vehicle.model, vehicle.year, vehicle.notes]
        );
        vehicleIdToUse = insert.rows[0].id;
      }
    } catch (e) {
      // ignore - user may be guest booking
    }
  }

  // insert booking record as pending
  const bookingRes = await db.query(
    `INSERT INTO bookings (user_id, technician_id, vehicle_id, service_id, start_at, end_at, location, total_price_pence, vat_amount_pence, status)
     VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10)
     RETURNING id, user_id, technician_id, service_id, start_at, end_at, total_price_pence, vat_amount_pence, status`,
    [null, technician_id || null, vehicleIdToUse || null, service_id, startTS.toISOString(), endTS.toISOString(), JSON.stringify(location), total, vatAmount, 'pending']
  );

  const booking = bookingRes.rows[0];

  // Create Stripe PaymentIntent
  const stripe = Stripe(process.env.STRIPE_SECRET_KEY);
  const pi = await stripe.paymentIntents.create({
    amount: total,
    currency: 'gbp',
    metadata: { bookingId: booking.id, serviceId: service_id },
    description: `Booking ${booking.id} - ${service_id}`,
    receipt_email: customer_email
  });

  // store stripe id in booking
  await db.query('UPDATE bookings SET stripe_payment_intent_id = $1 WHERE id = $2', [pi.id, booking.id]);

  res.json({ booking, clientSecret: pi.client_secret });
}));

// get booking
app.get('/api/bookings/:id', asyncHandler(async (req, res) => {
  const { id } = req.params;
  const r = await db.query('SELECT * FROM bookings WHERE id = $1', [id]);
  if (r.rows.length === 0) return res.status(404).json({ error: 'Booking not found' });
  res.json({ booking: r.rows[0] });
}));

// update booking status (admin/technician)
app.patch('/api/bookings/:id', requireAuth, asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { status } = req.body;
  if (!status) return res.status(400).json({ error: 'status required' });
  await db.query('UPDATE bookings SET status = $1, updated_at = now() WHERE id = $2', [status, id]);
  res.json({ ok: true });
}));

/**
 * Stripe webhook - verify signature in production
 */
app.post('/api/webhooks/stripe', bodyParser.raw({ type: 'application/json' }), async (req, res) => {
  const sig = req.headers['stripe-signature'];
  const stripe = Stripe(process.env.STRIPE_SECRET_KEY);
  let event;
  try {
    if (process.env.STRIPE_WEBHOOK_SECRET) {
      event = stripe.webhooks.constructEvent(req.body, sig, process.env.STRIPE_WEBHOOK_SECRET);
    } else {
      // If no webhook secret set (dev), parse the body as JSON
      event = JSON.parse(req.body.toString());
    }
  } catch (err) {
    console.error('Webhook signature verification failed:', err.message);
    return res.status(400).send(`Webhook Error: ${err.message}`);
  }

  // handle events
  switch (event.type) {
    case 'payment_intent.succeeded': {
      const pi = event.data.object;
      const bookingId = pi.metadata.bookingId;
      if (bookingId) {
        await db.query('UPDATE bookings SET payment_status = $1, status = $2, updated_at = now() WHERE stripe_payment_intent_id = $3', ['paid', 'confirmed', pi.id]);
        // TODO: send confirmation SMS/email via Twilio/SendGrid
      }
      break;
    }
    case 'payment_intent.payment_failed': {
      const pi = event.data.object;
      // mark booking unpaid / notify user
      await db.query('UPDATE bookings SET payment_status = $1 WHERE stripe_payment_intent_id = $2', ['unpaid', pi.id]);
      break;
    }
    default:
      console.log('Unhandled event type', event.type);
  }

  res.json({ received: true });
});

/**
 * Postcode lookup proxy (Postcodes.io) - simple
 * Example: GET /api/postcode/SW1A1AA
 */
app.get('/api/postcode/:postcode', asyncHandler(async (req, res) => {
  const raw = req.params.postcode || '';
  const cleaned = raw.replace(/\s+/g, '');
  const url = `${process.env.POSTCODESIO_API || 'https://api.postcodes.io'}/postcodes/${encodeURIComponent(cleaned)}`;
  const r = await fetch(url);
  const data = await r.json();
  if (!data || data.status !== 200) return res.status(404).json({ error: 'Postcode not found' });
  res.json({ result: data.result });
}));

/**
 * Minimal error handler
 */
app.use((err, req, res, next) => {
  console.error(err);
  const status = err.status || 500;
  res.status(status).json({ error: err.message || 'internal_error' });
});

/**
 * Start server
 */
const port = process.env.PORT || 3000;
app.listen(port, () => console.log(`Server running on port ${port}`));
FROM node:20-alpine

WORKDIR /usr/src/app
COPY package*.json ./
RUN npm ci --production

COPY . .

ENV NODE_ENV=production
EXPOSE 3000
CMD ["node", "src/index.js"]
version: '3.8'
services:
  db:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: detailermade_dev
    volumes:
      - db-data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
  server:
    build: ./server
    command: sh -c "npm run migrate && npm run dev"
    volumes:
      - ./server:/usr/src/app
      - ./db:/db
    environment:
      DATABASE_URL: postgres://postgres:postgres@db:5432/detailermade_dev
      JWT_SECRET: dev_jwt_secret_change_me
      STRIPE_SECRET_KEY: sk_test_replace
      STRIPE_WEBHOOK_SECRET:
      POSTCODESIO_API: https://api.postcodes.io
      NODE_ENV: development
      PORT: 3000
    ports:
      - "3000:3000"
    depends_on:
      - db

volumes:
  db-data:
# Detailermade-UK Backend (scaffold)

## Prereqs
- Docker & docker-compose
- (Optional) Node 18+/npm if you want to run without Docker

## Quick start (Docker)
1. Copy `.env.example` to `server/.env` and set any secrets you want.
2. Run:
